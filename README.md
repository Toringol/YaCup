# **YaCup Backend**
## **Пробный раунд**
### **A. Камни и украшения**

|                     |                                  |
|---------------------|----------------------------------|
| Ограничение времени | 1 секунда                        |
| Ограничение памяти  | 64Mb                             |
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |
  
Даны две строки строчных латинских символов: строка J и строка S. Символы, входящие в строку  
J, — «драгоценности», входящие в строку S — «камни». Нужно определить, какое  
количество символов из S одновременно являются «драгоценностями». Проще говоря, нужно  
проверить, какое количество символов из S входит в J.  
  
Это разминочная задача, к которой мы размещаем готовые решения. Она очень простая и  
нужна для того, чтобы вы могли познакомиться с нашей автоматической системой проверки  
решений. Ввод и вывод осуществляется через файлы, либо через стандартные потоки ввода-  
вывода, как вам удобнее.  
  
Python: https://pastebin.com/bCKpF9Ru. В качестве языка выбирайте Python 2.7.  
C++: https://pastebin.com/e5wMVV1u. Можно использовать GNU c++ 14 4.9.  
C#: https://pastebin.com/UZU4iCB0. Язык: Mono C# 5.2.0.  
Java: https://pastebin.com/SbLfafuv. Подойдёт, например, язык Java 8.  
Golang: https://pastebin.com/cWTJXY1J. Выбирайте компилятор gcc go.  
  
#### **Формат ввода**

На двух первых строках входного файла содержатся две строки строчных латинских символов:  
строка J и строка S. Длина каждой не превосходит 100 символов.

#### **Формат вывода**

Выходной файл должен содержать единственное число — количество камней, являющихся  
драгоценностями.

#### **Пример**

|         Ввод	      |            Вывод                 |
|---------------------|----------------------------------|
| ( ab )  ( aabbccd ) | 4                                |
  

### **B. Будильники**

|                     |                                  |
|---------------------|----------------------------------|
| Ограничение времени | 2 секунды                        |
| Ограничение памяти  | 256Mb                            |
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |
  
Работа в большинстве IT-компаний имеет много преимуществ: нет дресс-кода, можно иногда  
поработать удалённо, классные и умные коллеги и, конечно же, свободный график! Однако  
свободный график и возможность работать удалённо требуют большой силы воли.  
Программист Алексей любит работать по ночам и не любит приходить на работу поздно.  
Чтобы точно проснуться с утра, Алексей каждый вечер заводит *N* будильников на своём  
телефоне. Каждый будильник устроен таким образом, что он звонит каждые *X* минут с того  
момента времени, на который его завели. Например, если будильник был заведён на момент  
времени *t*<sub>*i*</sub>, то он будет звонить в моменты времени *t*<sub>*i*</sub>, *t*<sub>*i*</sub> + *X*, *t*<sub>*i*</sub> + 2 * *X* и так далее. При  
этом если какие-то два будильника начинают звонить в один момент времени, то  
отображается только один из них.  

Известно, что прежде чем проснуться, Алексей каждое утро слушает ровно *K* будильников,  
после чего просыпается. Определите момент времени, когда Алексей проснётся.  

#### **Формат ввода**

Первая строка содержит три целых числа *N*, *X* и *K* (1 ≤ *N* ≤ 10<sup>5</sup>, 1 ≤ *X*, *K* ≤ 10<sup>9</sup>) —  
количество будильников, периодичность звонков и количество будильников, которое нужно  
отключить, чтобы Алексей проснулся.  
Вторая строка содержит *N* целых чисел *t*<sub>*i*</sub>, *t*<sub>*i*</sub>, ..., *t*<sub>*N*</sub> (1 ≤ *t*<sub>*i*</sub> ≤ 10<sup>9</sup>) — моменты времени на  
которые были заведены будильники.

#### **Формат вывода**

Выведите одно число — момент времени, когда Алексей проснётся.

#### **Пример 1**

|         Ввод	              |            Вывод                  |
|-----------------------------|-----------------------------------|
| ( 6 5 10 )  ( 1 2 3 4 5 6 ) | 10                                |

#### **Пример 2**

|         Ввод	              |            Вывод                  |
|-----------------------------|-----------------------------------|
| ( 5 7 12 )  ( 5 22 17 13 8 )| 27                                |
  
#### **Примечание**

Во втором примере заведено 5 будильников с периодичностью звонков 7. Например, первый  
будильник будет звонить в моменты времени 5, 12, 19, 26, 33, и т. д. Если рассмотреть все  
будильники одновременно, то они будут звонить в следующие моменты времени: 5, 8, 12, 13,  
15, 17, 19, 20, 22 (2-й и 5-й будильники одновременно), 24, 26, 27, 29, ... На 12-й по счёту  
звонок Алексей должен проснуться, чему соответствует момент времени 27.

### **C. Интересная игра**

|                     |                                  |
|---------------------|----------------------------------|
| Ограничение времени | 2 секунды                        |
| Ограничение памяти  | 256Mb                            |
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |

Петя и Вася играют в интересную игру. Сначала Вася объявляет, сколько очков нужно набрать,  
чтобы игра закончилась. Затем Петя берет карточки, на которых написаны целые  
неотрицательные числа, и начинает выкладывать их на стол одну за другой. Если на  
карточке число, кратное пяти, то Вася получает одно очко. Если на карточке число, кратное трем, то  
одно очко получает Петя. Если на карточке число, не кратное ни трем, ни пяти, или наоборот,  
кратное им обоим, то очков не получает никто.
Как только кто-то из участников наберет количество очков, которое назвал в начале игры Вася,  
игра прекращается и этот игрок становится победителем. Если никто из участников не набрал  
нужного количества очков, но при этом все карточки закончились, то победителем считается  
игрок, у которого больше очков. Если все карточки закончились, а очков поровну, то  
объявляется ничья.  

Петя и Вася иногда очень спешат, поэтому хотят не играть в игру полностью, а сразу узнать,  
кто выиграл бы при известных начальных данных. Они попросили вас написать программу,  
которая поможет ответить на этот вопрос.  

#### **Формат ввода**

В первой строке через пробел даны два целых положительных числа: количество очков *K*,  
которое объявляет в начале игры Вася, и количество карточек *N*, которые есть у Пети (
1 ≤ *K* ≤ 1000, 1 ≤ *N* ≤ 10<sup>6</sup>). В следующей строке даны *N* целых неотрицательных чисел,  
разделенных пробелом, каждое из которых не превосходит 1000.  

#### **Формат вывода**

В единственной строке выведите Petya, если в игре побеждает Петя, Vasya, если в игре  
побеждает Вася, или Draw, если победителя выявить не удалось.  

#### **Пример 1**

|         Ввод	                     |            Вывод                  |
|------------------------------------|-----------------------------------|
| ( 3 10 )  ( 1 2 3 4 5 6 7 8 9 10 ) | Petya                             |

#### **Пример 2**

|         Ввод	                                |            Вывод                  |
|-----------------------------------------------|-----------------------------------|
| ( 4 12 )  ( 5 10 15 20 3 6 9 25 30 12 21 24 ) | Vasya                             |

### **F. Сложение чисел**

|                     |                                  |
|---------------------|----------------------------------|
| Ограничение времени | 2 секунды                        |
| Ограничение памяти  | 64Mb                             |
| Ввод                | стандартный ввод или input.txt   |
| Вывод               | стандартный вывод или output.txt |

Разработчики бекенда часто взаимодействуют с многочисленными API, результаты которых  
нужно ещё и дополнительно обрабатывать. Сейчас вам придётся сделать именно это!  
Во входном файле четыре строчки. В первой находится URL сервера, во второй — номер  
порта. В следующих двух строках записаны два целых 32-разрядных числа: соответственно, **a**  
и **b**. Необходимо осуществить GET-запрос к серверу по указанному номеру порта, передав  
значения чисел **a** и **b** в значениях одноимённых параметров запроса. Сервер ответит JSON-  
массивом из целых чисел. Сумму этих чисел необходимо распечатать в выходной файл.
  
Гарантируется, что общее количество чисел в ответе не превосходит 100, при этом каждое из  
них — 32-разрядное знаковое целое число.
  
#### **Формат ввода**

Строка — URL сервера.  
Целое число — порт сервера.   
Целое число — число **a**.   
Целое число — число **b**.  

#### **Формат вывода**

Единственная строка выходного файла должна содержать целое число, равное сумме чисел  
из ответа сервера.

#### **Пример**

|         Ввод	                            |            Вывод                  |
|-------------------------------------------|-----------------------------------|
| ( http://127.0.0.1 )  ( 7777 ) ( 2 ) ( 4 )| 1279                              |

#### **Примечание**

Для решений на языке Python доступны библиотеки json, requests и urllib.  
Для решений на языке Java доступна библиотека json-simple версии 1.1.1. Соответствующие  
функции импорта могут иметь вид:
import org.json.simple.JSONArray;   
import org.json.simple.JSONObject;   
import org.json.simple.parser.JSONParser;   
import org.json.simple.parser.ParseException;  
  
Для решений на языке C++ доступны библиотеки libcurl v7.47.0 и nlohmann/json v3.8.0.  
Соответствующие директивы include выглядят так:
#include <curl/curl.h>   
#include "json.hpp"  
  
Для решений на языке Golang доступны все стандартные пакеты, включая encoding/json,  
net/http, sort и другие.  
  
Пример ответа сервера для первого теста:  
curl "http://127.0.0.1:7777?a=2&b=4"  
[  
  8,  
  6,  
  -2,  
  2,  
  4,  
  17,  
  256,  
  1024,  
  -17,  
  -19  
]